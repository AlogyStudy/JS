函数的作用域，不取决于运行时的环境，而取决于函数声明时的环境.

如果var 声明的变量名与形参名称一致. 不产生影响., 因为AO的str属性已经存在不产生影响.


fn.call(obj);
让fn以运行，并且fn中的this以obj身份运行

有了信号量，啥都能做。

变量没有被任何的定时器，事件监听“持有”，所以清理内存.

重复的相同结构，相同业务，功能类似的东西，体现“自治”。

-------------------------------------------------------

font

font-family: "Merriweather", "PT Serif", Georgia, "Times New Roman", serif;

Gotham SSm A

-------------------------------------------------------
requset

require 
response
------------------------------------------------------

满意是最高标准，满意就不怕麻烦。

time花在进步上。

把API换成业务

编程素养

-------------------------------------------------------

用一个类管理另一个类，类似地图的， 二维数组，数组，关联数组这样的形式。

			
地图类型：
	转块类:  地图阵
		二维数组
				
	贪吃蛇类：
		一维数组	


-------------------------------------------------------
帧率手机上不会上百。帧率固定20帧

-------------------------------------------------------
对象本无根，类型亦无形。本来无一物，何处惹尘埃。

对一个东西的思维模式

-------------------------------------------------------

在删除东西的时候，应该多注意，时候会影响遍历的长度。


运动的单元和触发事件的对象一般不需要同一个人。

-------------------------------------------------------
无缝滚动


设置信号量


复制一份
设置折返点(turnBackPoint)   offsetLeft
	chrome 图片机理.
	
	注意：move(); 函数调用。图片加载完毕
end  

函数设置：
设置setInterval
	处理信号量
	判断折返点 
	赋值
	
添加监听，自身调用。
	

	
----------------------------------------



animate 
	
动画间隔时间。//浏览器检测 设置 interval
	
当前的值 作为信号量  需要json作为载体。
	利用targetJSON，获得关联数组的下标。通过getComputeStyle()  获得样式表值。
 

计算函数执行次数

	
计算步长，JSON

准备结束.

开启定时器

	赋值
	设置
	//opaict处理
	
count 与 maxCount 条件
	
	清除定时器

	总体思路：
		信号量JSON semaphoreJSON每一帧都变化。
	
	

//拉终停表
	清除定时器前，把最后位置调整正确。	


	
	
----------------------------------------------	
	
	
	
animate ease
参数验证
动画间隔时间。//浏览器检测 设置 interval
初始状态
变化状态
计算函数执行次数
当前帧数
end

定时器
	执行tween ，（当前执行时间，初始位置，变化量位置，总时间）
	设置
	
添加，计数器
	清除定时器
	拉终停表
	

	
------------------------------------------------------	
	
	
	
	

传统轮播	
复制节点
添加信号量

end 

监听事件
	右按钮 	(后置判断 需要放入回调)(先拉后换)
	自动轮播
	鼠标离开
	鼠标开启

	左按钮  后置判断正常  （假0替换真0，把后面拉回来，替换）
	小圆点自身

	更换小圆点事件 (图片可能是5，但是小圆点下标最大是4，要用n过渡下。	)

		
		
------------------------------------------------	

小圆点 
	图片可能是5，但是小圆点下标最大是4，要用n过渡下。	

	
----------------------------------------------------	
	
	
三位置轮播图
原信号量一张图
	移除
改变信号量(后一张图准备)
新信号量
	移动到视口中

信号量
end 

添加监听
right
left
circles
	this.index 与 idx 大小位置判断	
			
	
	
-----------------------------------------------------

传统轮播图
间歇模型
呼吸轮播
三位置轮播
输送带轮播
异形轮播


----------------------------------------------
间歇模型
信号量
复制第一个li的内容
end

move()	(注意标识到临界值的时候要拉回)

开启定时器


-----------------------------------------------
呼吸轮播
	原理：
	原来的信号量的图片淡出
	信号量变化
	信号量变化后的图片淡入

信号量
end
添加监听
	左边按钮
	右边按钮
	小圆点		
-------------------------------------------sanw--


三位置轮播
	
信号量
end
rightBtn
	信号量前后值
leftBtn
	信号量前后值
小圆点
	不知道在左还是右，需要判断 this.index 与信号量的判断

----------------------------------------------
输送带法
准备工作，
原理：	
	所有图片隐藏，当成存储箱
	
	重新建立一个盒子，运动单元只放两张图片。每次更换两张图片信号量

		
克隆前两张图片,并插入

信号量
end
rightBtn
	需要点击的时候拉回
	准备新的图片
	清空运动单元
	再次克隆，插入

leftBtn

小圆点



----------------------------------------------------
异形滚动
	七张图片，left，top，width，height，存储起来。
	利用数组操作，可以弹出或写入。--强行改序号

构建数据，放入数组中。

end
事件监听
rightBtn 
	运动
	第一张图瞬移到最后的一个位置.

leftBtn
	运动
	最后一张图瞬移到第一个位置	


------------------------------------------------
百叶窗
	寻找各自定位值.
	遍历，然后索引值比较。
	索引值和each中的回调函数比较



----------------------------------------------
拼图轮播
	原理：各个盒子中携带不同的背景定位值，定位值
	每一个人的left值，top值不同。
	第几行第几列算法：
	列：	取模  
	行：	除数	

	创建图片算法：
		双层for循环.
		i  和 j 各自left，top,初始值 定位值.
			
		横着10个格子 
		竖着10个格子


创建各个图片

each 添加动画
	设置left，top值。
		left： i%列*每个盒子宽度
		top: parseInt(i/列)*每个盒子高度
	
-------------------------
图片都是不显示，
只有一张显示.  需要有一个容器，容纳这个图.

创建图片,<div>容器
信号量
右按钮监听
	遍历，添加动画，
		left
		top
	动画飞入一张后，应该消失用真的图片替换.  需要计算动画执行完后 setTimeout(); [不使用animate中的回调，是不知道使用哪一个替换]
	div飞入之后，立刻拉回，回到原来为止,然后换图.
		
	碎片换图。

有定时器的情况下。
	使用 lock节流.
	



-------------------------------------------------------
手风琴
利用排它方式添加 class或者隐藏显示. 
	判断是否可见 is(':visible')




-------------------------------------------------------
放大镜
	大图，
	小图。
	小图内拖拽
小图盒子move监听	
	一个盒子在另一个盒子内move. (注意是小盒子的到document的宽度)
	修正鼠标移动到值中间.
	封锁四边.
	赋值left，top。

控制大图背景定位：
	大图比例 大图:拖拽盒子


------------------------------------------------------
回到顶部

寻找tween参数的值
开启定时器(设表先关)
	运动到相同的帧，清除定时器
	设置scrollTop值.


------------------------------------------------------
导航楼层
	含有	





-------------------------------------------------------
网易汽车滚轮条
搜集数据：
	运动单元的宽度.
	
信号量-图片信号量
      -滑块信号量
比例
滑块初始宽度
	
添加监听
	rightBtn
		处理二个信号量
		验收二个信号量
		设置值				
	mousedown-拖拽模型
		
	
两个信号量，让两个运动单元都运动不产生误会。



	
		
	
		


-----------------------------------------

打气球
1：构造函数
	需要的属性	

2：在原型上扩展
	init - 创建容器
		创建DOM
			添加class
			设置样式
			设置背景 ， 通过信号量（范围信号量）。

	fly - 动画
		setInterval()
			不同的速度
				2*self.scroe
	biubiu 
		清除定时器			
		消失移除DOM


	在init中扩展onclick
	在onclick中计算分数.

定时器累计
	frameCount
	倒计时时间
	时间判断为0
		window.location.reload();		
----------------------------------------------------
jq实现模拟滚动条
收集数据
	比例
	信号量
jquerUI 执行拖拽
	


----------------------------------------------------
this备份
idx 备份




----------------------------------------------------
反弹算法
	碰边之后，后置验证，判断当前的top，left是否超过，如果超过，反方向。
	_this.deltaX = -_this.delataX;
	
1°= π/180
		

-----------------------------------------------------
碰撞检测
	距离、位置
	实现的原理就是检测两个物体是否重叠
	
	矩形检测
	数学上可以处理成比较中心点的坐标在x和y方向上的距离和宽度的关系。即两个矩形中心点在x方向的距离的绝对值小于等于矩形宽度和的二分之一，同时y方向的距离的绝对值小于等于矩形高度和的二分之一。
	圆形检测
	计算两个圆心之间的距离是否小于两个圆的半径和。	

-----------------------------------------------------

挡板球
	砖块类Block
		属性：
			left
			top
		方法：
			redner()
			check()	
				检测自己是否被撞到 (不是小球拥有被撞到的方法，而是自己拥有被撞倒的方法，效率问题，小球不用循环去检测，而砖块自身去检测是否被撞到)
			hide()  
				消失
	
	地图类Map
		属性
			map 二维数组 

			blockArr  存放block 的对象。

		方法
			create(),根据map属性，建立整个砖块，游戏画布
			createBlocks(); 检查是否被撞击	
	
	小球类Ball		
		属性
			left
			top	
		方法
			render()
			move()  撞边检测，反弹业务
		
问题：为什么不用小球来判断是否被撞到，而选择砖块？
	效率问题，如果选择小球来判断是否被撞到，需要循环每个砖块，效率低下。
	选择砖块自身被撞到，检测可以让每个砖块自己检测，效率较高。
	
	小球每次除了自身运动外，都要每次让Block类中的check方法检测是否被撞到。  通过map类来控制 砖块。

	挡板类  Recket
		属性
			left	
			top
		方法
			render()
			bindEvent()
			check();	

	小球的碰撞挡板可以反弹，业务加在挡板类，使用观察者模式，挡板观察小球的位置，小球等到了挡板，告知小球改变运动轨迹。
	在订阅中，不需要一个订阅另一个再定义另一个。要观察一个人。 				
	小球中添加执行是否被撞击。	


Map类 -> 砖块类Block 
	类和 类之间也可以产生关系调用。
	
Ball类
	Ball中的move，10毫秒检测地图的checkAll方法,地图的checkAll()控制Block检测.	
	调用Racket的check()	

Ball->Map->Block;

Ball
	map.checkAllBlock();
	Map
		this.blockArr[i].check();
		Block
			Block.prototype.check();
	
循环检查，放入到数组中的blockArr中的new Block 拥有 check() .

map.checkAllBlock(); 中删除DOM，出现循环问题，加标记alive表示是否存活


解决小球碰到同一个砖块中，使用函数返回值，然后根据返回过来的值，来跳出循环。


游戏终止条件 
_this.top >= box.clientHeight - _this.d;


------------------------------------------------------
呼吸轮播
	构造函数
		属性
			idx
			timer	
				
		方法
			自动轮播	
			bingEvent()
	
	.prototype.next();
	.prototype.prve();
	.prototype.goto(num);	
	.prototpype.bingEvent();
		right
		left	
		小圆点
	.prototype.auto()
				
				
				
-------------------------------------------------------模板字符串
数据绑定函数
请求数据
循环数组
	组建DOM(竞速Img)

	添加DOM

	瀑布流算法
		left
		top

建立信号量	
监听滚动事件
	添加节流

	设置高度
		_.max(colHeight); //放在数组更改之后
	loading 的显示隐藏
		原始隐藏
		getJSONRender() 刚执行 显示
		到达最后一个JSON后隐藏 ,更改文本
		图片加载完，隐藏.
-------------------------------------------------------
贪吃蛇
Map类
	width
	height
		
	render()  //初始化画布
	存放DOM对象,二维数组
		tds = [i][j] = td //报错，
		二维数组. 需要二次创建 push()	
	Map.reset();

Snake类
	属性：
	color
	length/bodyArr   --> [{x: ,y: }] 表示 所在的table中的格格	
	way
	//移动方向
	direction
	
	方法：
	render()
		重置画布所有的元素，都没有类名
		Map.reset();
		根据bodyArr中的x，y，进行地图的添加red类.
	
	update()
		//后面一项删除 
		//前面增加一项  -- 原来一项+1. unshift()	
		更改方向  -- 这边不能够判断 为反方向性的问题.
		update中判断吃食物逻辑。 bodyArr[0]的x,y 和 foodx，foody 是否相等.
	
	添加事件绑定
	bindEvnet()
			事件绑定中判断是否有反方向问题.
	growup()

	
Food类
	foodx
	foody
	
	render()
	chanePosition()
	noBody() //不能生成在蛇身上.
		食物的x，y和  snake.bodyArr.x,snake.bodyArr.y的是否相等

定时器更新
	//渲染小蛇
	snake.render();
	//蛇移动
	snake.update();


地图-->蛇-->食物
生成地图，同时二维数组，用作产生颜色，存放小蛇，食物.	

そなのか		
			

-------------------------------------------------------

ajax分页：

JobRow()
	属性：
	this.dict
	this.dict.link
	this.strDom 
	this.$strDom
	this.$rowBtn
	this.$detail
			
	方法：

	render()
		添加到页面

	bindEvent()
		this.$rowBtn.click()		
			处理隐藏显示	
			小箭头
			
JobTable()
	addElement();
	gotoPage()
	执行ajax提交
	

把原来的东西删除。
	JobTable.addElement();
	this.jobRows = [];
		new 出来一个 就 把自己添加到该数组中。
		在jobRow 中自杀方法.
			fillMySelf()
	在gotoPage() 方法中调用fillMySelf();
		//先remove， 后new。

JobTable类管理 -> JobRow类;
JobTable类管理 -> PageNav类;


导航类
PageNav(curPage,maxPage)   -- 参数，一个函数所关心的是什么。
	this.curPage
	this.maxPage
	this.$DOM
	this.$lis 
	
	render()
		为$lis 添加数字和类
	curPage>=1 && curPage<=3
	
	curPage<=9 && curPage>=7
	
	中间位置变化
	unpdate()   -- 每一次重新new 就不需要 update
		
		
一个状态存在后， 另一个状态改变，反应-->这就该改变update


JobTable 才拥有ajax方法，可以控制 总共有多少页。
		

				
-------------------------------------------------------

把导航条 放 如 JobTable属性中.
	中介则模式,是一个对象属性。

为了防止点击的时候调用重新new出来。 使用中介者模式，把pageNav 挂载到 JobTable中。 然后在ajax中 得到总页数。 再调用pageNav.update()。


处理路由
	点击处理路由
	URL直接enter处理路由


	模板修正





------------------------------------------------------
组件开发
	组件发，不依赖任何框架，不需要使用JQ。
	组件开发，有一个思路，就是自己管自己，不需要更多的复用。	

	
获取DOM

选择元素小方法
	_byClassName

下一张
.prototype._next()
	有两个状态同时产生，使用数组[]，数组中有两个类似对象,表示两个状态
	信号量建立，
	后置判断
	调用_this.animate();
上一张
.prototype._prve();
到某一张
.prototype._goto(num);
	判断num和当前索引值的关系。来决定是从左边过来还是右边过来。判断方向。
	
添加节流
设表先关
	

简易的运动框架
.prototype.animate()


改变小圆点 ，业务。
_changeCircle 


_bindEvent();绑定监听
	事件绑定的this问题.
		需要通过函数嵌套，备份this
	
添加自动轮播：_autoPlay();
	定时器需要再次定义一个.一个是负责动画，一个负责自动轮播
。

-------------------------------------------------------
移动端轮播图
	
为图片准备位置
添加绑定事件
	准备 idx ，next，prev
	获取delta 
	move	
		改变位置(赋值)
	end
		判断是否决定成功
		distance = ev.changeTouches[0].clientX - startX; ,或者右边滑动且时间小于500
		在三种条件下，判断滑动的方向，改变信号量，再赋值。
		三个信号量都要改变，备份原先的idx为当前方向的反方向，然后操作的方向为当前的idx， 当前的方向，自增自减，后置判断。	
			

//主要点：			
	方向的判断	
		var distance = ev.changedTouches[0].clientX - startX;
		distance >= windowWidth/2 || (distance > 20) && (time < 400)	

	三个信号量的统一
		//滑动 右边， 备份原来的idx，为next
		next = idx;
		
		idx = prev;
		
		prev--;
		if ( prev < 0 ) {
			prev = 4;
		}


-------------------------------------------------------
	


惯性算法

	move移动的过程中的数值，push到数组中。
	计算数组的最后两个点间的距离。 距离就决定的滑动的快慢。
	targetX = nowX + s * 3;
	比原来的 增加最后两点之间的距离的常数倍
	信号量后置判断.
		增加贝塞尔曲线特性的transition改变.

-------------------------------------------------------


